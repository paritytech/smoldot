<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The [`RequestsSubscriptions`] state machine holds a list of clients, pending outgoing messages, pending requests, and active subscriptions."><meta name="keywords" content="rust, rustlang, rust-lang, requests_subscriptions"><title>smoldot::json_rpc::requests_subscriptions - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-6827029ac823cab7.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../../static.files/light-ebce58d0a40c3431.css"><link rel="stylesheet" disabled href="../../../static.files/dark-f23faae4a2daf9a6.css"><link rel="stylesheet" disabled href="../../../static.files/ayu-8af5e100b21cd173.css"><script id="default-settings" ></script><script src="../../../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../../../static.files/main-c55e1eb52e1886b4.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../smoldot/index.html"><div class="logo-container"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../smoldot/index.html"><div class="logo-container"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Module requests_subscriptions</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Module <a href="../../index.html">smoldot</a>::<wbr><a href="../index.html">json_rpc</a>::<wbr><a class="mod" href="#">requests_subscriptions</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/smoldot/json_rpc/requests_subscriptions.rs.html#18-1099">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The <a href="struct.RequestsSubscriptions.html" title="RequestsSubscriptions"><code>RequestsSubscriptions</code></a> state machine holds a list of clients, pending outgoing messages,
pending requests, and active subscriptions.</p>
<p>The code in this module is the front line of the JSON-RPC server. It can be subject to DoS
attacks, and is therefore designed to properly distribute resources between JSON-RPC clients.
If you use this data structure as intended, your design is safe from DoS attacks.</p>
<h2 id="usage"><a href="#usage">Usage</a></h2>
<p>The <a href="struct.RequestsSubscriptions.html" title="RequestsSubscriptions"><code>RequestsSubscriptions</code></a> is meant to be shared (through an <code>Arc</code> or similar) between many
different asynchronous tasks that call its methods.</p>
<blockquote>
<p><strong>Note</strong>: While off-topic for this module, you are strongly encouraged to put all these
asynchronous tasks within a single <code>FuturesUnordered</code>. This ensure that no two
tasks can be processed at the same time, and thus limits the total CPU usage of
all these tasks combined to <code>1.0</code> CPU cores. This leaves other CPU cores free for
the more urgent processing.</p>
</blockquote>
<p>There should be:</p>
<ul>
<li>One lightweight task for each client currently connected to the server.</li>
<li>A fixed number of lightweight tasks (e.g. 16) dedicated to answering requests.</li>
</ul>
<h3 id="clients"><a href="#clients">Clients</a></h3>
<p>Whenever a new client connects to the server, spawn a new task dedicated to this client, that:</p>
<ul>
<li>Calls <a href="struct.RequestsSubscriptions.html#method.add_client" title="RequestsSubscriptions::add_client"><code>RequestsSubscriptions::add_client</code></a>, denying the client if the function returns an
error.</li>
<li>Repeatedly polls the socket for a new request then calls
<a href="struct.RequestsSubscriptions.html#method.queue_client_request" title="RequestsSubscriptions::queue_client_request"><code>RequestsSubscriptions::queue_client_request</code></a>.</li>
<li>At the same time (for example in a <code>select!</code> block) calls
<a href="struct.RequestsSubscriptions.html#method.next_response" title="RequestsSubscriptions::next_response"><code>RequestsSubscriptions::next_response</code></a> then sends the response to the socket.</li>
<li>When the client disconnects, calls <a href="struct.RequestsSubscriptions.html#method.remove_client" title="RequestsSubscriptions::remove_client"><code>RequestsSubscriptions::remove_client</code></a>.</li>
</ul>
<p>It is important that no new request is polled from the socket as long as
<a href="struct.RequestsSubscriptions.html#method.queue_client_request" title="RequestsSubscriptions::queue_client_request"><code>RequestsSubscriptions::queue_client_request</code></a> hasn’t been able to queue the previous
request. This makes it possible to back-pressure the JSON-RPC client in case when the queue
is slow to be processed.</p>
<p>Similarly, do not call <a href="struct.RequestsSubscriptions.html#method.next_response" title="RequestsSubscriptions::next_response"><code>RequestsSubscriptions::next_response</code></a> before the socket has been
able to send the previous response. Not calling <a href="struct.RequestsSubscriptions.html#method.next_response" title="RequestsSubscriptions::next_response"><code>RequestsSubscriptions::next_response</code></a> often
enough will lead to back-pressure being applied onto
<a href="struct.RequestsSubscriptions.html#method.queue_client_request" title="RequestsSubscriptions::queue_client_request"><code>RequestsSubscriptions::queue_client_request</code></a>, which will in turn back-pressure the sending
side of the JSON-RPC client.</p>
<p>Note that if a client is removed at the same time as a call to
<a href="struct.RequestsSubscriptions.html#method.next_response" title="RequestsSubscriptions::next_response"><code>RequestsSubscriptions::next_response</code></a> is in progress, the call will never return  It is
your responsibility to interrupt this function call when the client is disconnected. If,
as advised above, everything is contained within a single task, this is normally not a problem
as you simply stop the task altogether after removing the client.</p>
<h3 id="requests"><a href="#requests">Requests</a></h3>
<p>There should be a certain, fixed, number of lightweight tasks dedicated to pulling requests
from the state machine and answering them.</p>
<p>Each of these lightweight tasks should:</p>
<ul>
<li>Call <a href="struct.RequestsSubscriptions.html#method.next_request" title="RequestsSubscriptions::next_request"><code>RequestsSubscriptions::next_request</code></a>. This function call sleeps until there is a
request available.</li>
<li>Parse the request that was returned and generate its response. This step should be relatively
fast (e.g. not more than one second), but can liberally perform asynchronous requests, lock
mutexes, etc.</li>
<li>Call <a href="struct.RequestsSubscriptions.html#method.respond" title="RequestsSubscriptions::respond"><code>RequestsSubscriptions::respond</code></a>.</li>
<li>Jump back to step 1.</li>
</ul>
<p>If these tasks are too busy and don’t call <a href="struct.RequestsSubscriptions.html#method.next_request" title="RequestsSubscriptions::next_request"><code>RequestsSubscriptions::next_request</code></a> often
enough, back-pressure will be applied onto <a href="struct.RequestsSubscriptions.html#method.queue_client_request" title="RequestsSubscriptions::queue_client_request"><code>RequestsSubscriptions::queue_client_request</code></a>,
which in turn applies back-pressure onto the JSON-RPC clients.</p>
<h3 id="subscriptions"><a href="#subscriptions">Subscriptions</a></h3>
<p>If a client-sent request requires starting a subscription, one of the
requests-pulling-dedicated tasks should call <a href="struct.RequestsSubscriptions.html#method.start_subscription" title="RequestsSubscriptions::start_subscription"><code>RequestsSubscriptions::start_subscription</code></a>.</p>
<p>It is the responsibility of the higher-level code to generate the JSON-RPC-client-facing
identifier of the subscription.</p>
<p>When a subscription is started, the higher-level code should spawn a new task dedicated to
sending back notifications to the client using <a href="struct.RequestsSubscriptions.html#method.push_notification" title="RequestsSubscriptions::push_notification"><code>RequestsSubscriptions::push_notification</code></a>,
<a href="struct.RequestsSubscriptions.html#method.try_push_notification" title="RequestsSubscriptions::try_push_notification"><code>RequestsSubscriptions::try_push_notification</code></a>, or
<a href="struct.RequestsSubscriptions.html#method.set_queued_notification" title="RequestsSubscriptions::set_queued_notification"><code>RequestsSubscriptions::set_queued_notification</code></a>.</p>
<p>The code on top should maintain a map of <code>JSON-RPC-client-facing identifier</code> to
<a href="struct.SubscriptionId.html" title="SubscriptionId"><code>SubscriptionId</code></a>. When the JSON-RPC client wants to unsubscribe, call
<a href="struct.RequestsSubscriptions.html#method.stop_subscription" title="RequestsSubscriptions::stop_subscription"><code>RequestsSubscriptions::stop_subscription</code></a>. This map should also contain a way to abort
the task dedicated to that subscription.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ClientId.html" title="smoldot::json_rpc::requests_subscriptions::ClientId struct">ClientId</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Config.html" title="smoldot::json_rpc::requests_subscriptions::Config struct">Config</a></div><div class="item-right docblock-short">Configuration to pass to <a href="struct.RequestsSubscriptions.html#method.new" title="RequestsSubscriptions::new"><code>RequestsSubscriptions::new</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RequestId.html" title="smoldot::json_rpc::requests_subscriptions::RequestId struct">RequestId</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RequestsSubscriptions.html" title="smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions struct">RequestsSubscriptions</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SubscriptionId.html" title="smoldot::json_rpc::requests_subscriptions::SubscriptionId struct">SubscriptionId</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TryQueueClientRequestError.html" title="smoldot::json_rpc::requests_subscriptions::TryQueueClientRequestError struct">TryQueueClientRequestError</a></div><div class="item-right docblock-short">Error returned by <a href="struct.RequestsSubscriptions.html#method.try_queue_client_request" title="RequestsSubscriptions::try_queue_client_request"><code>RequestsSubscriptions::try_queue_client_request</code></a>.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.AddClientError.html" title="smoldot::json_rpc::requests_subscriptions::AddClientError enum">AddClientError</a></div><div class="item-right docblock-short">Error returned by <a href="struct.RequestsSubscriptions.html#method.add_client" title="RequestsSubscriptions::add_client"><code>RequestsSubscriptions::add_client</code></a> and
<a href="struct.RequestsSubscriptions.html#method.add_client_mut" title="RequestsSubscriptions::add_client_mut"><code>RequestsSubscriptions::add_client_mut</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.StartSubscriptionError.html" title="smoldot::json_rpc::requests_subscriptions::StartSubscriptionError enum">StartSubscriptionError</a></div><div class="item-right docblock-short">Error returned by <a href="struct.RequestsSubscriptions.html#method.start_subscription" title="RequestsSubscriptions::start_subscription"><code>RequestsSubscriptions::start_subscription</code></a>.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="smoldot" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.1 (d5a82bbd2 2023-02-07)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>