// Copyright (C) 2019-2020 Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Connecting to the peer-to-peer network.
//!
//! The [`Network`] struct provided by this module allows you to connect to other nodes and
//! exchange messages with them.
//!
//! # Concepts
//!
//! Here are the major concepts that you should understand in order to use this module:
//!
//! - **Peer** vs **node**. A **node** is a machine that is part of the network. A **peer** is a
//! node which we are directly connected to. Be aware that this documentation doesn't necessarily
//! strictly enforce the distinction between the node.
//!
//! - A **peer ID**, or **node ID**, represented by the [`PeerId`] struct, is the identity of a
//! node on the network (not necessarily a peer). It is the encoding of a public key. Whenever
//! connection is established, an
//! [ECDH](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman) handshake is
//! performed and communications encrypted. It is therefore guaranteed that all communications
//! with a peer come from or arrive to the owner of the corresponding private key.
//!
//! - A **multiaddr* is an abstraction over a way to reach a node, such as an IP address and a
//! port. TODO: expand
//!
//! - A **bootstrap node** is a node whose address is hard-coded into the client on startup. You
//! are encouraged to pass the list of bootstrap nodes' peer IDs and their addresses as part of the
//! configuration of the network.
//!
//! - A **substream** is a subdivision of a connection. Each connection with a peer is subdivided
//! into multiple substreams multiplexed together. Communications are ordered within each
//! individual substreams, but not necessarily between substreams.
//!
//! - TODO: finish
//!

use core::fmt;

pub use libp2p::{Multiaddr, PeerId};
pub use worker::{
    BlockData, BlocksRequestConfig, BlocksRequestConfigStart, BlocksRequestDirection,
    BlocksRequestFields, Config, Event, Network, RequestId, ScaleBlockHeader,
};

#[doc(inline)]
pub use libp2p::multiaddr;
pub use libp2p::wasm_ext;

mod behaviour;
mod debug_info;
mod discovery;
mod generic_proto;
mod legacy_message;
mod request_responses;
mod schema;
mod transport;
mod worker;

pub mod task;

/// Parses a string address and splits it into Multiaddress and PeerId, if
/// valid.
pub fn parse_str_addr(addr_str: &str) -> Result<(PeerId, Multiaddr), ParseErr> {
    let addr: Multiaddr = addr_str.parse()?;
    parse_addr(addr)
}

/// Splits a Multiaddress into a Multiaddress and PeerId.
pub fn parse_addr(mut addr: Multiaddr) -> Result<(PeerId, Multiaddr), ParseErr> {
    let who = match addr.pop() {
        Some(multiaddr::Protocol::P2p(key)) => {
            PeerId::from_multihash(key).map_err(|_| ParseErr::InvalidPeerId)?
        }
        _ => return Err(ParseErr::PeerIdMissing),
    };

    Ok((who, addr))
}

/// Error that can be generated by `parse_str_addr`.
#[derive(Debug)]
pub enum ParseErr {
    /// Error while parsing the multiaddress.
    MultiaddrParse(multiaddr::Error),
    /// Multihash of the peer ID is invalid.
    InvalidPeerId,
    /// The peer ID is missing from the address.
    PeerIdMissing,
}

impl fmt::Display for ParseErr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ParseErr::MultiaddrParse(err) => write!(f, "{}", err),
            ParseErr::InvalidPeerId => write!(f, "Peer id at the end of the address is invalid"),
            ParseErr::PeerIdMissing => write!(f, "Peer id is missing from the address"),
        }
    }
}

impl std::error::Error for ParseErr {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            ParseErr::MultiaddrParse(err) => Some(err),
            ParseErr::InvalidPeerId => None,
            ParseErr::PeerIdMissing => None,
        }
    }
}

impl From<multiaddr::Error> for ParseErr {
    fn from(err: multiaddr::Error) -> ParseErr {
        ParseErr::MultiaddrParse(err)
    }
}
