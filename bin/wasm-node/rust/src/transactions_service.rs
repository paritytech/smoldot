// Smoldot
// Copyright (C) 2019-2021  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

//! Background transactions service.
//!
//! The role of the [`TransactionsService`] is to manage the transactions that the user wants to
//! send out, and report about their status.
//!
//! The [`TransactionsService`] is most of the time idle. When the user wants to emit a
//! transaction on the network, it gets reported to the service, which then tries to send it to
//! the peers the node is currently connected to. Afterwards, the service will inspect the stream
//! of best and finalized blocks to find out whether the transaction has been included or not.

use crate::{network_service, sync_service};

use futures::{channel::mpsc, lock::Mutex, prelude::*};
use smoldot::libp2p::peer_id::PeerId;
use std::{collections::HashMap, pin::Pin, sync::Arc};

/// Configuration for a [`TransactionsService`].
pub struct Config {
    /// Closure that spawns background tasks.
    pub tasks_executor: Box<dyn FnMut(Pin<Box<dyn Future<Output = ()> + Send>>) + Send>,

    /// Access to the network, and index of the chain to sync from the point of view of the
    /// network service.
    pub network_service: (Arc<network_service::NetworkService>, usize),

    /// Service responsible for synchronizing the chain.
    pub sync_service: Arc<sync_service::SyncService>,
}

/// See [the module-level documentation](..).
pub struct TransactionsService {
    /// Sending messages to the background task.
    to_background: Mutex<mpsc::Sender<ToBackground>>,
}

impl TransactionsService {
    /// Builds a new service.
    pub async fn new(mut config: Config) -> Self {
        let (to_background, from_foreground) = mpsc::channel(8);

        (config.tasks_executor)(Box::pin(background_task(
            config.network_service.0,
            config.network_service.1,
            config.sync_service,
            from_foreground,
        )));

        TransactionsService {
            to_background: Mutex::new(to_background),
        }
    }

    /// Adds a transaction to the service. The service will try to send it out as soon as
    /// possible.
    ///
    /// The return value of this method is a channel which will receive updates on the state
    /// of the extrinsic. The channel is closed when no new update is expected.
    ///
    /// > **Note**: Dropping the value returned does not cancel sending out the extrinsic.
    pub async fn submit_extrinsic(&self, transaction: &[u8]) -> mpsc::Receiver<TransactionStatus> {
        // TODO: think about the size and full-ness of this channel
        let (updates_report, rx) = mpsc::channel(16);

        self.to_background
            .lock()
            .await
            .send(ToBackground::SubmitTransaction {
                transaction_bytes: transaction.to_owned(),
                updates_report,
            })
            .await
            .unwrap();

        rx
    }
}

/// Update on the state of an extrinsic in the service.
///
/// > **Note**: Because this code isn't an *actual* transactions pool that leverages the runtime,
/// >           some variants (e.g. `Invalid`) are missing compared to the ones that can be found
/// >           in Substrate, as they can't possibly be generated by this implementation.
/// >           Additionally, an equivalent to the `Ready` state in Substrate is missing as it
/// >           is the default state.
#[derive(Debug)]
pub enum TransactionStatus {
    /// Transaction has been broadcasted to the given peers.
    Broadcast(Vec<PeerId>),
    /// Detected a best block that contains this transaction.
    InBlock([u8; 32]),
    /// Can be sent after [`TransactionStatus::InBlock`] to notify that a re-org happened and the
    /// current best tree of blocks no longer contains the transaction.
    ///
    /// Contains the same block as was previously passed in [`TransactionStatus::InBlock`].
    Retracted([u8; 32]),
    /// Transaction has been dropped because the service was full.
    Dropped,
    /// Transaction has been included in a finalized block.
    Finalized([u8; 32]),
    /// Transaction is not in a finalized block, but is included in the 512th ancestor of the
    /// current best block. This can happen if finality has stalled or is simply not available
    /// on the chain.
    FinalityTimeout([u8; 32]),
}

/// Message sent from the foreground service to the background.
enum ToBackground {
    SubmitTransaction {
        transaction_bytes: Vec<u8>,
        updates_report: mpsc::Sender<TransactionStatus>,
    },
}

/// Background task running in parallel of the front service.
async fn background_task(
    network_service: Arc<network_service::NetworkService>,
    network_chain_index: usize,
    sync_service: Arc<sync_service::SyncService>,
    mut from_foreground: mpsc::Receiver<ToBackground>,
) {
    let mut pending_transactions =
        HashMap::<_, _, fnv::FnvBuildHasher>::with_capacity_and_hasher(16, Default::default());

    // TODO: must periodically re-send transactions that aren't included in block yet
    // TODO: must download the bodies of blocks as long as we have transactions in flight

    loop {
        match from_foreground.next().await {
            None => return,
            Some(ToBackground::SubmitTransaction {
                transaction_bytes,
                mut updates_report,
            }) => {
                let peers_sent = network_service
                    .clone()
                    .announce_transaction(network_chain_index, &transaction_bytes)
                    .await;

                if !peers_sent.is_empty() {
                    let _ = updates_report
                        .send(TransactionStatus::Broadcast(peers_sent))
                        .await;
                }

                pending_transactions.insert(transaction_bytes, updates_report);
            }
        }
    }
}
